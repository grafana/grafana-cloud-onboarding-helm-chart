// Discover the kube-state-metrics endpoints
discovery.kubernetes "node_exporter" {
	role = "pod"

	selectors {
		role  = "pod"
		label = "app.kubernetes.io/name=node-exporter,app.kubernetes.io/instance=k8smon" // Should be templatized and found by survey_info
	}

	namespaces {
		names = ["default"] // Should be templatized and found by survey_info
	}
}

discovery.relabel "node_exporter" {
	targets = discovery.kubernetes.node_exporter.targets

	// keep only the specified metrics port name, and pods that are Running and ready
	rule {
		source_labels = [
			"__meta_kubernetes_pod_container_port_name",
			"__meta_kubernetes_pod_container_init",
			"__meta_kubernetes_pod_phase",
			"__meta_kubernetes_pod_ready",
		]
		separator = "@"
		regex     = "metrics@false@Running@true"
		action    = "keep"
	}

	// Set the instance label to the node name
	rule {
		source_labels = ["__meta_kubernetes_pod_node_name"]
		action        = "replace"
		target_label  = "instance"
	}

	// set the namespace label
	rule {
		source_labels = ["__meta_kubernetes_namespace"]
		target_label  = "namespace"
	}

	// set the pod label
	rule {
		source_labels = ["__meta_kubernetes_pod_name"]
		target_label  = "pod"
	}

	// set the container label
	rule {
		source_labels = ["__meta_kubernetes_pod_container_name"]
		target_label  = "container"
	}

	// set a workload label
	rule {
		source_labels = [
			"__meta_kubernetes_pod_controller_kind",
			"__meta_kubernetes_pod_controller_name",
		]
		separator    = "/"
		target_label = "workload"
	}
	// remove the hash from the ReplicaSet
	rule {
		source_labels = ["workload"]
		regex         = "(ReplicaSet/.+)-.+"
		target_label  = "workload"
	}

	// set the app name if specified as metadata labels "app:" or "app.kubernetes.io/name:" or "k8s-app:"
	rule {
		action        = "replace"
		source_labels = [
			"__meta_kubernetes_pod_label_app_kubernetes_io_name",
			"__meta_kubernetes_pod_label_k8s_app",
			"__meta_kubernetes_pod_label_app",
		]
		separator    = ";"
		regex        = "^(?:;*)?([^;]+).*$"
		replacement  = "$1"
		target_label = "app"
	}

	// set the component if specified as metadata labels "component:" or "app.kubernetes.io/component:" or "k8s-component:"
	rule {
		action        = "replace"
		source_labels = [
			"__meta_kubernetes_pod_label_app_kubernetes_io_component",
			"__meta_kubernetes_pod_label_k8s_component",
			"__meta_kubernetes_pod_label_component",
		]
		regex        = "^(?:;*)?([^;]+).*$"
		replacement  = "$1"
		target_label = "component"
	}
}

prometheus.scrape "node_exporter" {
	targets           = discovery.relabel.node_exporter.output
	job_name          = "integrations/node_exporter"
	scrape_interval   = "60s"
	scheme            = "http"
	bearer_token_file = ""

	tls_config {
		insecure_skip_verify = true
	}

	clustering {
		enabled = true
	}
	forward_to = [prometheus.relabel.node_exporter.receiver]
}

prometheus.relabel "node_exporter" {
	max_cache_size = 100000

	rule {
		source_labels = ["__name__"]
		regex         = "up|scrape_samples_scraped|node_cpu.*|node_exporter_build_info|node_filesystem.*|node_memory.*|node_network_receive_bytes_total|node_network_receive_drop_total|node_network_transmit_bytes_total|node_network_transmit_drop_total|process_cpu_seconds_total|process_resident_memory_bytes"
		action        = "keep"
	}
	// Drop metrics for certain file systems
	rule {
		source_labels = ["__name__", "fstype"]
		separator     = "@"
		regex         = "node_filesystem.*@(ramfs|tmpfs)"
		action        = "drop"
	}

	rule {
		target_label = "cluster"
		replacement  = sys.env("CLUSTER_NAME")
	}

	forward_to = [prometheus.remote_write.kube_state_metrics.receiver]
}

// Write metrics to your Grafana Cloud Prometheus instance.
prometheus.remote_write "kube_state_metrics" {
	endpoint {
		url = "https://prometheus-prod-13-prod-us-east-0.grafana.net/api/prom/push"

		basic_auth {
			username = "1867758"
			password = sys.env("GCLOUD_RW_API_KEY")
		}
	}
}
